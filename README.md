# Курсовая работа, Ильиных Т.А., ИБ-117
запуск для тестирования (на компьютере установлена windows 10,java 14, gradle 6.4.1) 
для windows 10 прописать в системных переменых patch для java и gradle.
(image/patch.png)
клонируем или скачиваем с репозитория на компьютер.
открываем командную строку windows (cmd) в папке проекта у меня это c:\Users\tanya\Documents\GitHub\kursovik\
(image/cmd1.png)
компилируем (собираем) проект с помощью команды: 
## gradle build
(image/cmd2.png)
Скомпилированый файл JCKurs.jar находится в папке .\build\libs\:
(у меня c:\Users\tanya\Documents\GitHub\kursovik\build\libs\)
Проводим тестирование нашего языка файлы примеров в папке .\test
1.Создаем  байт код нашего языка для виртуальной java машины (JVM) :
## java -jar .\build\libs\JCKurs.jar .\test\string.jc
(image/cmd3.png)
Получили файл .\test\TestClass.class, который является байт кодом.
2. Запустим этот файл с помощью команды:
## java -cp .\test\ TestClass
(image/cmd3.png)
Декомпилированный байт код можно посмотреть с помощью команды:
## javap -v .\test\TestClass.class
(image/cmd4.png)

 


Проект включает в себя лексер, парсер. Грамматика - это совмещение двух языков программирования Java и C.  Использовался генератор анализаторов для формальных языков ANTLR.

## Изменено/добавлено:
Создана грамматика записана в файле rules.g4. Также добавлено изображение дерева разбора.
![Изменено/добавлено:](image/antlr4_parse_tree.png)
## Сторонние библиотеки

* org.antlr:antlr4:4.8 （для лексического и грамматического анализа）
* org.ow2.asm:asm:8.0.1 （используется для создания байт-кода JVM）

## Поддержка основных языковых функций

* Пространства имен `namespace`
* структура `struct`
* Типы данных：`int` , `double` , `char` , `String`
* `if`, `elif` ,`else` логические блоки
* `for` ，`while`, `break` ，`continue` циклические блоки

## Архитектура компилятора

![Архитектура компилятора](image/Shema1.png)

### Лексический / грамматический анализ

В лексическом анализе используется сторонняя библиотека ANTLR. Все лексическое описание файл грамматики в src/main/antlr/rules.g4

### Семантический анализ

ANTLR использует шаблон Visitor для предоставления доступа к дереву разбора и может рекурсивно обходить дерево, генерируя синтаксическое дерево и добавляя атрибуты.
Через наследование XXXBaseVisitor<...> для получения доступа к дереву разбора.

### Информация о символах и ссылки

Дерево обхода начинается с корневого узла и постепенно спускается, но оно не является строго обходом глубины, поскольку не все атрибуты могут быть получены путем обхода глубины. В процессе обхода дерева другим XXXBaseVisitor<...> подклассом SymbolTableGenerator информация о символах получается из текущего контекста.

### AST
Узлы синтаксического дерева можно условно разделить на два типа: один - это узел, в котором хранится фактическая информация, например, узел, в котором хранится предложение, узел, в котором хранится переменная, а другой - узел, который задает структуру, например, узел, который задает структуру цикла и структуру логического суждения. Эти узлы сами по себе не несут информацию, но она используется в качестве организатора дочерних узлов для указания появления новых структур.

Узлы синтаксического дерева являются Node типами подклассов

Все дочерние узлы каждого узла хранятся в List<Node>структуре. NodeДалее делятся на подклассы, такие как DefinitionNode, RefNode другие подклассы. Основная информация, хранящаяся в узле, - это информация о типе (если она соответствует сущности), информация о значении (если она буквальная), справочная информация (если это ссылка на имя) и т. д.
  
###  Синтаксическое дерево
Иллюстрация синтаксического дерева, созданного в предыдущем примере, выглядит следующим образом (это дерево, напечатанное горизонтально):
